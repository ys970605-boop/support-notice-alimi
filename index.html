<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>K-Food Conquest .io | ê±°ëŒ€ ë¬¸ëª… ì „ìŸ</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #05050a; overflow: hidden; font-family: 'Apple SD Gothic Neo', sans-serif; touch-action: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        #scoreboard { 
            position: absolute; top: 15px; right: 15px; background: rgba(0,0,0,0.8); border-radius: 12px; padding: 12px; width: 220px; color: #fff; pointer-events: auto; border: 1px solid #444;
            max-height: 300px; overflow-y: auto; scrollbar-width: thin;
        }
        .score-row { display: flex; flex-direction: column; margin-bottom: 8px; border-bottom: 1px solid #222; padding-bottom: 4px; }
        .score-info { display: flex; justify-content: space-between; font-weight: bold; font-size: 12px; margin-bottom: 3px; }
        .score-bar-bg { width: 100%; height: 4px; background: #111; border-radius: 2px; overflow: hidden; }
        .score-bar { height: 100%; transition: width 0.5s; }
        
        #title-box { position: absolute; top: 15px; left: 15px; background: rgba(0,0,0,0.8); padding: 12px 20px; border-radius: 12px; color: white; border: 1px solid #444; }
        #title-box h1 { margin: 0; font-size: 18px; color: #fadb14; }
        #my-stats { margin-top: 5px; font-size: 12px; color: #00d2ff; }

        #level-up-toast {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            background: rgba(255, 215, 0, 0.9); color: #000; padding: 12px 40px;
            border-radius: 50px; font-weight: 900; font-size: 28px;
            display: none; z-index: 100; box-shadow: 0 0 20px rgba(255,215,0,0.5);
        }

        #game-over { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); padding: 50px; border-radius: 30px; text-align: center; color: white; display: none; pointer-events: auto; border: 3px solid #ff4d4f; }
        #game-over button { background: #fadb14; color: #000; border: none; padding: 15px 40px; font-size: 20px; font-weight: bold; border-radius: 40px; cursor: pointer; margin-top: 25px; }
        
        canvas { display: block; width: 100%; height: 100%; }
        
        /* ë¯¸ë‹ˆë§µ */
        #minimap {
            position: absolute; bottom: 20px; right: 20px; width: 150px; height: 150px;
            background: rgba(0,0,0,0.5); border: 2px solid #444; border-radius: 10px;
        }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div id="title-box">
            <h1>MEGA ë¬¸ëª… ì „ìŸ .io</h1>
            <div id="my-stats">ì ìœ ìœ¨: 0% | ì‹œëŒ€: ê°œì²™ ì‹œëŒ€ â›º</div>
        </div>
        <div id="scoreboard"></div>
        <div id="level-up-toast"></div>
        <div id="game-over">
            <h2 style="font-size: 40px; color: #ff4d4f; margin-top:0;">íŒ¨ë°°!</h2>
            <p>ë‹¹ì‹ ì˜ ë¬¸ëª…ì´ ë‹¤ë¥¸ êµ­ê°€ì— ì˜í•´ ì •ë³µë˜ì—ˆìŠµë‹ˆë‹¤.</p>
            <p style="font-size: 24px; color: #fadb14;">ìµœì¢… ë­í‚¹: <span id="final-rank">0</span>ìœ„</p>
            <button onclick="startGame()">ìƒˆ êµ­ê°€ ê±´ì„¤ (ì¬ë„ì „)</button>
        </div>
    </div>
    <div id="minimap">
        <canvas id="miniCanvas"></canvas>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const miniCanvas = document.getElementById('miniCanvas');
        const mctx = miniCanvas.getContext('2d');

        // ë§µ í¬ê¸° 10ë°° ì´ìƒ í™•ì¥ (200x200)
        const W = 200, H = 200;
        let TILE = 40; 
        let offsetX = 0, offsetY = 0;

        const TEAMS = [
            { id: 1, name: "í•œêµ­", flag: "ğŸ‡°ğŸ‡·", color: "#52c41a" },
            { id: 2, name: "ì¤‘êµ­", flag: "ğŸ‡¨ğŸ‡³", color: "#ff4d4f" },
            { id: 3, name: "ì¼ë³¸", flag: "ğŸ‡¯ğŸ‡µ", color: "#d9d9d9" },
            { id: 4, name: "ëŒ€ë§Œ", flag: "ğŸ‡¹ğŸ‡¼", color: "#1890ff" },
            { id: 5, name: "ë¯¸êµ­", flag: "ğŸ‡ºğŸ‡¸", color: "#3f51b5" },
            { id: 6, name: "ì˜êµ­", flag: "ğŸ‡¬ğŸ‡§", color: "#795548" },
            { id: 7, name: "ë…ì¼", flag: "ğŸ‡©ğŸ‡ª", color: "#ffc107" },
            { id: 8, name: "í”„ë‘ìŠ¤", flag: "ğŸ‡«ğŸ‡·", color: "#2196f3" },
            { id: 9, name: "ë¸Œë¼ì§ˆ", flag: "ğŸ‡§ğŸ‡·", color: "#4caf50" },
            { id: 10, name: "ì¸ë„", flag: "ğŸ‡®ğŸ‡³", color: "#ff9800" },
            { id: 11, name: "ëŸ¬ì‹œì•„", flag: "ğŸ‡·ğŸ‡º", color: "#9e9e9e" },
            { id: 12, name: "ì´íƒˆë¦¬ì•„", flag: "ğŸ‡®ğŸ‡¹", color: "#8bc34a" },
            { id: 13, name: "ìºë‚˜ë‹¤", flag: "ğŸ‡¨ğŸ‡¦", color: "#f44336" },
            { id: 14, name: "í˜¸ì£¼", flag: "ğŸ‡¦ğŸ‡º", color: "#00bcd4" },
            { id: 15, name: "ìŠ¤í˜ì¸", flag: "ğŸ‡ªğŸ‡¸", color: "#e91e63" },
            { id: 16, name: "ë©•ì‹œì½”", flag: "ğŸ‡²ğŸ‡½", color: "#cddc39" },
            { id: 17, name: "ë² íŠ¸ë‚¨", flag: "ğŸ‡»ğŸ‡³", color: "#f44336" },
            { id: 18, name: "íƒœêµ­", flag: "ğŸ‡¹ğŸ‡­", color: "#673ab7" },
            { id: 19, name: "í„°í‚¤", flag: "ğŸ‡¹ğŸ‡·", color: "#ff5722" },
            { id: 20, name: "ë„¤ëœë€ë“œ", flag: "ğŸ‡³ğŸ‡±", color: "#ff9800" }
        ];

        const STAGES = [
            { min: 0, name: "ê°œì²™ ì‹œëŒ€", emoji: "â›º", build: ["â›º", "ğŸ”¥"] },
            { min: 2, name: "ì •ì°© ì‹œëŒ€", emoji: "ğŸ ", build: ["ğŸ ", "ğŸ¡"] },
            { min: 5, name: "ë„ì‹œ ì‹œëŒ€", emoji: "ğŸ¢", build: ["ğŸ¢", "ğŸª"] },
            { min: 10, name: "ë©”íŠ¸ë¡œí´ë¦¬ìŠ¤", emoji: "ğŸ™ï¸", build: ["ğŸ™ï¸", "ğŸ›ï¸"] },
            { min: 20, name: "ë¯¸ë˜ ë¬¸ëª…", emoji: "ğŸš€", build: ["ğŸš€", "ğŸ›°ï¸"] }
        ];

        let gridOwner = new Int8Array(W * H);
        let gridTrail = new Int8Array(W * H);
        let gridBuildings = new Int8Array(W * H); // index of build emoji
        let players = [];
        let gameLoop, isGameOver = false;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            miniCanvas.width = 150; miniCanvas.height = 150;
        }
        window.addEventListener('resize', resize);
        resize();

        function startGame() {
            document.getElementById('game-over').style.display = 'none';
            isGameOver = false;
            gridOwner.fill(0); gridTrail.fill(0); gridBuildings.fill(0);
            
            players = [];
            // í”Œë ˆì´ì–´ ìƒì„± (ëœë¤ ìœ„ì¹˜)
            players.push(spawnPlayer(1));
            
            // AI ë´‡ 19ê°œ ìƒì„±
            for(let i=2; i<=20; i++) {
                players.push(spawnPlayer(i));
            }

            if(gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(update, 80);
            window.requestAnimationFrame(draw);
        }

        function spawnPlayer(id) {
            let sx = 10 + Math.floor(Math.random() * (W-20));
            let sy = 10 + Math.floor(Math.random() * (H-20));
            
            // ì´ˆê¸° ì˜í† 
            for(let i=-2; i<=2; i++) {
                for(let j=-2; j<=2; j++) {
                    gridOwner[(sx+i)*H + (sy+j)] = id;
                }
            }
            return {
                id: id, x: sx, y: sy, dx: 0, dy: (sy > H/2 ? -1 : 1), 
                nextDx: 0, nextDy: (sy > H/2 ? -1 : 1),
                trail: [], alive: true, score: 25, level: 1
            };
        }

        function captureTerritory(pId) {
            let p = players.find(x => x.id === pId);
            p.trail.forEach(t => {
                gridOwner[t.x*H + t.y] = pId;
                gridTrail[t.x*H + t.y] = 0;
            });
            p.trail = [];

            // Flood Fillë¡œ ê°‡íŒ ê³µê°„ ì±„ìš°ê¸°
            let visited = new Uint8Array(W * H);
            let queue = [];
            for(let x=0; x<W; x++) {
                if(gridOwner[x*H + 0] !== pId) { queue.push(x, 0); visited[x*H + 0] = 1; }
                if(gridOwner[x*H + (H-1)] !== pId) { queue.push(x, H-1); visited[x*H + (H-1)] = 1; }
            }
            for(let y=0; y<H; y++) {
                if(gridOwner[0*H + y] !== pId) { queue.push(0, y); visited[0*H + y] = 1; }
                if(gridOwner[(W-1)*H + y] !== pId) { queue.push(W-1, y); visited[(W-1)*H + y] = 1; }
            }

            let head = 0;
            while(head < queue.length) {
                let y = queue[head+1], x = queue[head]; head += 2;
                let ds = [[0,1],[0,-1],[1,0],[-1,0]];
                for(let d of ds) {
                    let nx = x+d[0], ny = y+d[1];
                    if(nx>=0 && nx<W && ny>=0 && ny<H && !visited[nx*H + ny] && gridOwner[nx*H + ny] !== pId) {
                        visited[nx*H + ny] = 1; queue.push(nx, ny);
                    }
                }
            }

            let newScore = 0;
            for(let i=0; i<W*H; i++) {
                if(!visited[i] && gridOwner[i] !== pId) {
                    gridOwner[i] = pId; gridTrail[i] = 0;
                    if(Math.random() < 0.05) gridBuildings[i] = Math.floor(Math.random()*2) + 1;
                }
                if(gridOwner[i] === pId) newScore++;
            }
            p.score = newScore;
        }

        function killPlayer(p) {
            p.alive = false;
            for(let i=0; i<W*H; i++) {
                if(gridOwner[i] === p.id) { gridOwner[i] = 0; gridBuildings[i] = 0; }
                if(gridTrail[i] === p.id) gridTrail[i] = 0;
            }
            if(p.id === 1) {
                isGameOver = true;
                clearInterval(gameLoop);
                document.getElementById('game-over').style.display = 'block';
            } else {
                // ë´‡ì€ ì ì‹œ í›„ ë¦¬ìŠ¤í°
                setTimeout(() => { if(!isGameOver) players[players.indexOf(p)] = spawnPlayer(p.id); }, 3000);
            }
        }

        function update() {
            if(isGameOver) return;

            players.forEach(p => {
                if(!p.alive) return;

                // ë´‡ ì§€ëŠ¥
                if(p.id !== 1) {
                    if(Math.random() < 0.05) {
                        const dirs = [[0,1],[0,-1],[1,0],[-1,0]].filter(d => d[0]!==-p.dx || d[1]!==-p.dy);
                        const rand = dirs[Math.floor(Math.random()*dirs.length)];
                        p.nextDx = rand[0]; p.nextDy = rand[1];
                    }
                    // ì˜í†  ë°–ìœ¼ë¡œ ë„ˆë¬´ ë©€ë¦¬ ë‚˜ê°€ë©´ ëŒì•„ì˜¤ê²Œ í•¨
                    if(p.trail.length > 15) {
                        // ëŒ€ëµì ì¸ ì¤‘ì‹¬ ë°©í–¥ìœ¼ë¡œ ì„ íšŒ
                        let homeX = p.x - p.dx*5, homeY = p.y - p.dy*5;
                    }
                }

                p.dx = p.nextDx; p.dy = p.nextDy;
                let nx = p.x + p.dx, ny = p.y + p.dy;

                if(nx<0 || nx>=W || ny<0 || ny>=H) { killPlayer(p); return; }

                let trailIdx = nx*H + ny;
                if(gridTrail[trailIdx] !== 0) {
                    let victim = players.find(v => v.id === gridTrail[trailIdx]);
                    if(victim) killPlayer(victim);
                    if(!p.alive) return;
                }

                if(gridOwner[trailIdx] === p.id) {
                    if(p.trail.length > 0) captureTerritory(p.id);
                } else {
                    p.trail.push({x:nx, y:ny});
                    gridTrail[trailIdx] = p.id;
                }
                p.x = nx; p.y = ny;
            });

            // ìŠ¤ì½”ì–´ ë° ë¬¸ëª… ì§„í™” ì—…ë°ì´íŠ¸
            let sc = new Int32Array(21);
            for(let i=0; i<W*H; i++) if(gridOwner[i] !== 0) sc[gridOwner[i]]++;
            
            players.forEach(p => {
                p.score = sc[p.id];
                let percent = (p.score / (W*H)) * 100;
                let stage = STAGES.find((s, i) => percent >= s.min && (STAGES[i+1] ? percent < STAGES[i+1].min : true));
                if(p.id === 1) {
                    document.getElementById('my-stats').innerText = `ì ìœ ìœ¨: ${percent.toFixed(1)}% | ì‹œëŒ€: ${stage.name} ${stage.emoji}`;
                    if(players.indexOf(p) === 0) { // ë‹¨ìˆœ ë­í‚¹ ì˜ˆì‹œ
                        let rank = [...players].sort((a,b)=>b.score-a.score).indexOf(p) + 1;
                        document.getElementById('final-rank').innerText = rank;
                    }
                }
            });

            updateScoreboard();
        }

        function updateScoreboard() {
            let sorted = [...players].filter(p => p.alive).sort((a,b) => b.score - a.score).slice(0, 10);
            let html = '';
            sorted.forEach(p => {
                let team = TEAMS.find(t => t.id === p.id);
                let percent = ((p.score / (W*H)) * 100).toFixed(1);
                html += `<div class="score-row">
                    <div class="score-info"><span>${team.flag} ${team.name}</span><span>${percent}%</span></div>
                    <div class="score-bar-bg"><div class="score-bar" style="width:${percent}%; background:${team.color}"></div></div>
                </div>`;
            });
            document.getElementById('scoreboard').innerHTML = html;
        }

        function draw() {
            if(isGameOver) return;
            ctx.fillStyle = '#05050a'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            let me = players.find(p => p.id === 1);
            if(me) { offsetX = canvas.width/2 - me.x * TILE; offsetY = canvas.height/2 - me.y * TILE; }
            
            ctx.save(); ctx.translate(offsetX, offsetY);

            // ê°€ì‹œ ì˜ì—­ ê³„ì‚° (ìµœì í™”)
            let xStart = Math.max(0, Math.floor(-offsetX / TILE));
            let xEnd = Math.min(W, Math.ceil((canvas.width - offsetX) / TILE));
            let yStart = Math.max(0, Math.floor(-offsetY / TILE));
            let yEnd = Math.min(H, Math.ceil((canvas.height - offsetY) / TILE));

            for(let x=xStart; x<xEnd; x++) {
                for(let y=yStart; y<yEnd; y++) {
                    let idx = x*H + y;
                    if(gridOwner[idx] !== 0) {
                        ctx.fillStyle = TEAMS.find(t => t.id === gridOwner[idx]).color;
                        ctx.globalAlpha = 0.3;
                        ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
                        ctx.globalAlpha = 1.0;
                        if(gridBuildings[idx] !== 0) {
                            let p = players.find(pl => pl.id === gridOwner[idx]);
                            let stage = STAGES[Math.min(STAGES.length-1, (p ? p.level-1 : 0))];
                            ctx.font = `${TILE*0.5}px Arial`; ctx.textAlign='center';
                            ctx.fillText(stage.build[gridBuildings[idx]-1] || stage.emoji, x*TILE + TILE/2, y*TILE + TILE/2);
                        }
                    }
                    if(gridTrail[idx] !== 0) {
                        ctx.fillStyle = TEAMS.find(t => t.id === gridTrail[idx]).color;
                        ctx.fillRect(x*TILE + TILE*0.3, y*TILE + TILE*0.3, TILE*0.4, TILE*0.4);
                    }
                }
            }

            players.forEach(p => {
                if(!p.alive) return;
                let t = TEAMS.find(team => team.id === p.id);
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(p.x*TILE+TILE/2, p.y*TILE+TILE/2, TILE*0.3, 0, Math.PI*2); ctx.fill();
                ctx.font = `${TILE*0.5}px Arial`; ctx.textAlign='center'; ctx.textBaseline='middle';
                ctx.fillText(t.flag, p.x*TILE+TILE/2, p.y*TILE+TILE/2+2);
            });
            ctx.restore();

            // ë¯¸ë‹ˆë§µ ê·¸ë¦¬ê¸°
            mctx.fillStyle = '#000'; mctx.fillRect(0,0,150,150);
            for(let i=0; i<W*H; i++) {
                if(gridOwner[i] !== 0) {
                    mctx.fillStyle = TEAMS.find(t => t.id === gridOwner[i]).color;
                    mctx.fillRect((i/H|0)*(150/W), (i%H)*(150/H), 2, 2);
                }
            }
            if(me) { mctx.fillStyle='#fff'; mctx.fillRect(me.x*(150/W), me.y*(150/H), 4, 4); }

            window.requestAnimationFrame(draw);
        }

        // ì¡°ì‘
        window.addEventListener('keydown', e => {
            let p = players.find(p => p.id === 1); if(!p || !p.alive) return;
            if(e.key === 'ArrowUp' && p.dy !== 1) { p.nextDx = 0; p.nextDy = -1; }
            if(e.key === 'ArrowDown' && p.dy !== -1) { p.nextDx = 0; p.nextDy = 1; }
            if(e.key === 'ArrowLeft' && p.dx !== 1) { p.nextDx = -1; p.nextDy = 0; }
            if(e.key === 'ArrowRight' && p.dx !== -1) { p.nextDx = 1; p.nextDy = 0; }
        });

        let tsX = 0, tsY = 0;
        window.addEventListener('touchstart', e => { tsX = e.touches[0].clientX; tsY = e.touches[0].clientY; }, {passive:false});
        window.addEventListener('touchmove', e => e.preventDefault(), {passive:false});
        window.addEventListener('touchend', e => {
            let p = players.find(p => p.id === 1); if(!p || !p.alive) return;
            let dx = e.changedTouches[0].clientX - tsX, dy = e.changedTouches[0].clientY - tsY;
            if(Math.abs(dx) > Math.abs(dy)) {
                if(dx > 30 && p.dx !== -1) { p.nextDx = 1; p.nextDy = 0; }
                else if(dx < -30 && p.dx !== 1) { p.nextDx = -1; p.nextDy = 0; }
            } else {
                if(dy > 30 && p.dy !== -1) { p.nextDx = 0; p.nextDy = 1; }
                else if(dy < -30 && p.dy !== 1) { p.nextDx = 0; p.nextDy = -1; }
            }
        });

        startGame();
    </script>
</body>
</html>
