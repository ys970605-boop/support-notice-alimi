<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>K-Infection .io | ë¦¬ì–¼ ì›”ë“œ ë§µ</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: #ff4d4f; touch-action: none; }
        #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        #news-ticker {
            position: absolute; top: 0; left: 0; width: 100%; background: rgba(139, 0, 0, 0.9); color: white; padding: 8px; font-size: 14px; font-weight: bold; overflow: hidden; white-space: nowrap; border-bottom: 2px solid #ff0000; box-shadow: 0 2px 10px rgba(255,0,0,0.5);
        }
        .ticker-move { display: inline-block; animation: ticker 25s linear infinite; }
        @keyframes ticker { from { transform: translateX(100%); } to { transform: translateX(-100%); } }

        #data-panel {
            position: absolute; bottom: 20px; right: 20px; background: rgba(0,0,0,0.85); border: 2px solid #ff4d4f; padding: 15px; border-radius: 10px; width: 260px; pointer-events: auto; box-shadow: 0 0 20px rgba(255,77,79,0.3);
        }
        .data-stat { display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 18px; font-weight: bold; }
        .dna-val { color: #fadb14; text-shadow: 0 0 10px rgba(250,219,20,0.5); }

        .evolve-btn {
            width: 100%; padding: 12px; background: linear-gradient(to bottom, #8b0000, #4a0000); color: white; border: 1px solid #ff4d4f; border-radius: 5px; cursor: pointer; font-weight: bold; margin-top: 8px; font-size: 13px;
        }
        .evolve-btn:hover { background: #ff0000; box-shadow: 0 0 15px #ff0000; }

        #ranking-board { position: absolute; top: 60px; left: 20px; background: rgba(0,0,0,0.8); border-left: 5px solid #ff4d4f; padding: 12px; min-width: 200px; border-radius: 0 8px 8px 0; }
        .rank-row { font-size: 13px; margin-bottom: 6px; font-weight: 600; }

        #game-over { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); border: 5px solid #ff0000; padding: 60px; text-align: center; display: none; pointer-events: auto; z-index: 100; border-radius: 20px; }
        
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="game-ui">
        <div id="news-ticker"><div class="ticker-move" id="ticker-text">ì „ ì§€êµ¬ì  ìœ„ê¸°: í•œêµ­ì—ì„œ ê¸°ì›í•œ ë³€ì¢… ë°”ì´ëŸ¬ìŠ¤ê°€ ëŒ€ë¥™ ê°„ ê²½ê³„ë¥¼ ë„˜ì–´ í™•ì‚° ì¤‘ì…ë‹ˆë‹¤... WHO, ìµœê³  ìˆ˜ì¤€ ê²½ë³´ ë°œë ¹...</div></div>
        
        <div id="ranking-board">
            <div style="font-size: 11px; margin-bottom: 8px; color: #aaa; letter-spacing: 1px;">GLOBAL THREAT LEVEL</div>
            <div id="ranks"></div>
        </div>

        <div id="data-panel">
            <div class="data-stat">DNA POINTS: <span id="dna-val" class="dna-val">500</span></div>
            <div class="data-stat" style="font-size: 14px;">ì§€êµ¬ ì ë ¹ë¥ : <span id="infect-rate">0.1</span>%</div>
            <button class="evolve-btn" onclick="spawnUnit('infector')">â˜£ï¸ ê°ì—¼ì²´ íŒŒê²¬ (100 DNA)</button>
            <button class="evolve-btn" onclick="spawnUnit('mutant')">ğŸ§Ÿ ë³€ì¢… ê´´ìˆ˜ ì§„í™” (300 DNA)</button>
        </div>

        <div id="game-over">
            <h1 style="color:#ff0000; font-size: 56px; margin:0;">EXTINCTION</h1>
            <p style="color:white; font-size: 20px; margin: 20px 0;">ì¸ë¥˜ ë¬¸ëª…ì´ ì™„ì „íˆ ì¢…ë§ì„ ë§ì´í–ˆìŠµë‹ˆë‹¤.</p>
            <button onclick="location.reload()" style="background:#ff0000; color:#fff; border:none; padding:15px 40px; cursor:pointer; font-weight:bold; border-radius:40px; font-size:18px;">START NEW STRAIN</button>
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = 3000, H = 2000;
        let camX = 0, camY = 0, zoom = 0.3, dna = 500;
        let entities = [], minerals = [], projectiles = [];
        const worldMap = new Image();
        // ê³ í•´ìƒë„ ë‹¤í¬ ìœ„ì„± ì§€ë„ ì´ë¯¸ì§€
        worldMap.src = 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Blue_Marble_Next_Generation_-_July_2004.jpg/1280px-Blue_Marble_Next_Generation_-_July_2004.jpg';

        const TEAMS = [
            { id: 1, name: "Virus(KR)", color: "#ff0000", flag: "â˜£ï¸", start: {x: 2450, y: 1450}, score: 0, alive: true },
            { id: 2, name: "North America", color: "#1890ff", flag: "ğŸ‡ºğŸ‡¸", start: {x: 600, y: 600}, score: 0, alive: true },
            { id: 3, name: "Europe", color: "#ffffff", flag: "ğŸ‡ªğŸ‡º", start: {x: 1550, y: 550}, score: 0, alive: true },
            { id: 4, name: "South America", color: "#52c41a", flag: "ğŸ‡§ğŸ‡·", start: {x: 900, y: 1550}, score: 0, alive: true }
        ];

        function initGame() {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            TEAMS.forEach(team => {
                entities.push({ id: Math.random(), type: 'core', team: team.id, x: team.start.x, y: team.start.y, hp: 6000, maxHp: 6000, size: 130 });
            });
            camX = TEAMS[0].start.x; camY = TEAMS[0].start.y;
            zoom = Math.min(canvas.width/W, canvas.height/H) * 1.3;
            setInterval(gameLoop, 50);
            requestAnimationFrame(draw);
        }

        function spawnUnit(type) {
            const cost = type === 'infector' ? 100 : 300;
            if(dna < cost) return;
            dna -= cost; updateUI();
            const core = entities.find(e => e.team === 1 && e.type === 'core');
            if(!core) return;
            const u = { id: Math.random(), type: type, team: 1, x: core.x, y: core.y, state: 'idle', cooldown: 0, targetPos: null };
            if(type === 'infector') { u.hp = 250; u.maxHp = 250; u.size = 22; u.speed = 7; u.range = 160; u.damage = 45; }
            else { u.hp = 1200; u.maxHp = 1200; u.size = 45; u.speed = 3.5; u.range = 350; u.damage = 180; u.splash = 180; }
            entities.push(u);
        }

        function gameLoop() {
            projectiles.forEach((p, idx) => {
                if(!p.target || p.target.hp <= 0) { projectiles.splice(idx, 1); return; }
                const d = Math.hypot(p.target.x - p.x, p.target.y - p.y);
                if(d < 20) {
                    if(p.splash) entities.forEach(ent => { if(ent.team !== p.team && Math.hypot(ent.x - p.x, ent.y - p.y) < p.splash) ent.hp -= p.damage; });
                    else p.target.hp -= p.damage;
                    projectiles.splice(idx, 1);
                } else { p.x += (p.target.x - p.x)/d * p.speed; p.y += (p.target.y - p.y)/d * p.speed; }
            });

            entities.forEach(e => {
                const team = TEAMS.find(t => t.id === e.team);
                if(!team.alive) return;
                if(!e.targetPos && e.speed > 0) {
                    let enemy = entities.find(ent => ent.team !== e.team && ent.hp > 0);
                    if(enemy) e.targetPos = { x: enemy.x + (Math.random()-0.5)*300, y: enemy.y + (Math.random()-0.5)*300 };
                }
                if(e.targetPos && e.speed > 0) {
                    const d = Math.hypot(e.targetPos.x - e.x, e.targetPos.y - e.y);
                    if(d > 10) { e.x += (e.targetPos.x - e.x)/d * e.speed; e.y += (e.targetPos.y - e.y)/d * e.speed; }
                    else e.targetPos = null;
                }
                if(e.type !== 'core') {
                    if(e.cooldown > 0) e.cooldown--;
                    let enemy = entities.find(ent => ent.team !== e.team && ent.hp > 0 && Math.hypot(ent.x - e.x, ent.y - e.y) < e.range);
                    if(enemy && e.cooldown <= 0) {
                        projectiles.push({ x: e.x, y: e.y, target: enemy, speed: 25, damage: e.damage, team: e.team, type: e.type, splash: e.splash });
                        e.cooldown = e.type === 'mutant' ? 50 : 15;
                    }
                }
            });

            if(Math.random() < 0.08) dna += 3; updateUI();
            TEAMS.forEach(t => { if(t.alive && !entities.some(ent => ent.team === t.id && ent.type === 'core')) { t.alive = false; entities = entities.filter(ent => ent.team !== t.id); } });
            entities = entities.filter(e => e.hp > 0);
            
            const totalInfect = (entities.filter(e => e.team === 1).length / 12).toFixed(1);
            document.getElementById('infect-rate').innerText = totalInfect;
            if(totalInfect > 95) document.getElementById('game-over').style.display = 'block';
            updateRanking();
        }

        function draw() {
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(canvas.width/2, canvas.height/2);
            ctx.scale(zoom, zoom);
            ctx.translate(-camX, -camY);

            // 1. ì‹¤ì œ ì§€ë„ ë°°ê²½
            ctx.globalAlpha = 0.6;
            ctx.drawImage(worldMap, 0, 0, W, H);
            ctx.globalAlpha = 1.0;

            // 2. ì‘ì „ ê²©ìì„  (Tactical Grid)
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.15)'; ctx.lineWidth = 1;
            for(let i=0; i<=W; i+=150) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,H); ctx.stroke(); }
            for(let i=0; i<=H; i+=150) { ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(W,i); ctx.stroke(); }

            // 3. ê°ì—¼ íˆíŠ¸ë§µ ì—°ì¶œ
            entities.filter(e => e.team === 1).forEach(e => {
                const grad = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, 250);
                grad.addColorStop(0, 'rgba(255, 0, 0, 0.25)');
                grad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = grad; ctx.fillRect(e.x-250, e.y-250, 500, 500);
            });

            projectiles.forEach(p => {
                ctx.fillStyle = '#ff4d4f'; ctx.beginPath(); ctx.arc(p.x, p.y, 10, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 15; ctx.shadowColor = '#f00';
            });
            ctx.shadowBlur = 0;

            // 4. ìœ ë‹› ë° ì½”ì–´ ë Œë”ë§
            entities.forEach(e => {
                const team = TEAMS.find(t => t.id === e.team);
                ctx.save();
                ctx.shadowBlur = 20; ctx.shadowColor = team.color;
                ctx.fillStyle = team.color;
                if(e.type === 'core') {
                    ctx.beginPath(); ctx.arc(e.x, e.y, e.size/2, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 4; ctx.stroke();
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 60px Arial'; ctx.fillText(team.flag, e.x-45, e.y+22);
                } else {
                    ctx.beginPath(); ctx.arc(e.x, e.y, e.size, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#000'; ctx.font = 'bold 20px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
                    ctx.fillText(e.type==='infector'?'â˜£ï¸':'ğŸ§Ÿ', e.x, e.y+2);
                }
                ctx.restore();
                // HP Bar
                ctx.fillStyle = 'rgba(255,0,0,0.3)'; ctx.fillRect(e.x - 60, e.y - e.size - 25, 120, 10);
                ctx.fillStyle = team.color; ctx.fillRect(e.x - 60, e.y - e.size - 25, 120 * (e.hp/e.maxHp), 10);
            });

            ctx.restore(); requestAnimationFrame(draw);
        }

        function updateRanking() {
            let html = '';
            [...TEAMS].sort((a,b) => b.score - a.score).forEach(t => {
                html += `<div class="rank-row" style="color:${t.color}">
                    <span>${t.flag} ${t.name}</span>: ${t.alive?'ACTIVE':'DESTROYED'}
                </div>`;
            });
            document.getElementById('ranks').innerHTML = html;
        }

        function updateUI() { document.getElementById('dna-val').innerText = Math.floor(dna); }
        canvas.addEventListener('wheel', e => { zoom *= (e.deltaY > 0 ? 0.85 : 1.15); zoom = Math.max(0.1, Math.min(3.0, zoom)); });
        let isDrag = false, lX, lY;
        canvas.addEventListener('mousedown', e => { isDrag = true; lX = e.clientX; lY = e.clientY; });
        window.addEventListener('mousemove', e => { if(isDrag) { camX -= (e.clientX - lX)/zoom; camY -= (e.clientY - lY)/zoom; lX = e.clientX; lY = e.clientY; } });
        window.addEventListener('mouseup', () => isDrag = false);
        initGame();
    </script>
</body>
</html>
