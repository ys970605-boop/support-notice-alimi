<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>K-Conquest RTS | í‰ë©´ ì„¸ê³„ ëŒ€ì „</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; overflow: hidden; font-family: 'Courier New', Courier, monospace; color: #0f0; touch-action: none; }
        #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        #ranking-board { position: absolute; top: 15px; left: 15px; background: rgba(0,30,0,0.8); border: 2px solid #0f0; border-radius: 5px; padding: 10px; width: 220px; pointer-events: auto; }
        .rank-row { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 4px; font-weight: bold; }
        .rank-row.me { color: #fadb14; }
        .rank-row.eliminated { color: #444; text-decoration: line-through; }

        #res-panel { position: absolute; top: 15px; right: 15px; background: rgba(0,30,0,0.8); border: 2px solid #0f0; padding: 10px 20px; border-radius: 5px; font-weight: bold; pointer-events: auto; }
        .res-val { color: #fadb14; font-size: 20px; }

        #build-panel { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,30,0,0.9); border: 2px solid #0f0; padding: 10px; border-radius: 10px; display: none; pointer-events: auto; gap: 10px; }
        .build-btn { background: #020; color: #0f0; border: 1px solid #0f0; padding: 8px; cursor: pointer; text-align: center; font-size: 11px; min-width: 80px; }
        .build-btn:hover { background: #040; }

        #msg-log { position: absolute; bottom: 20px; left: 20px; color: #0f0; font-size: 13px; text-shadow: 1px 1px 2px #000; }
        #game-over { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #000; border: 3px solid #f00; padding: 40px; text-align: center; display: none; pointer-events: auto; z-index: 100; }
        
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="game-ui">
        <div id="ranking-board"><div id="ranks"></div></div>
        <div id="res-panel">GOLD: <span id="gold-val" class="res-val">600</span></div>
        <div id="msg-log">í‰ë©´ ì„¸ê³„ ì§€ë„ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤. ë³‘ë ¥ì„ ì§€íœ˜í•˜ì—¬ ì„¸ê³„ë¥¼ ì •ë³µí•˜ì‹­ì‹œì˜¤.</div>
        
        <div id="build-panel">
            <button class="build-btn" onclick="produceUnit('worker')">SCV (â›ï¸)<br>50G</button>
            <button class="build-btn" onclick="produceUnit('soldier')">MARINE (âš”ï¸)<br>100G</button>
            <button class="build-btn" onclick="produceUnit('tank')">TANK (ğŸ’£)<br>300G</button>
            <button class="build-btn" onclick="produceUnit('tower')">TOWER (ğŸ›¡ï¸)<br>250G</button>
        </div>

        <div id="game-over">
            <h1 id="over-title" style="color:#f00">MISSION FAILED</h1>
            <p id="over-msg"></p>
            <button onclick="location.reload()" style="background:#0f0; color:#000; border:none; padding:10px 20px; cursor:pointer; font-weight:bold;">RESTART</button>
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = 3000, H = 2000; // ë„“ê²Œ í¼ì³ì§„ ì„¸ê³„ ì§€ë„ í¬ê¸°
        let camX = 0, camY = 0, gold = 600;
        let selectedUnits = [];
        let selectionBox = null;

        const TEAMS = [
            { id: 1, name: "í•œêµ­(Asia)", color: "#52c41a", flag: "ğŸ‡°ğŸ‡·", start: {x: 2400, y: 1500}, score: 0, alive: true },
            { id: 2, name: "ë¯¸êµ­(America)", color: "#1890ff", flag: "ğŸ‡ºğŸ‡¸", start: {x: 500, y: 500}, score: 0, alive: true },
            { id: 3, name: "ìœ ëŸ½(EU)", color: "#d9d9d9", flag: "ğŸ‡ªğŸ‡º", start: {x: 1500, y: 500}, score: 0, alive: true },
            { id: 4, name: "ë¸Œë¼ì§ˆ(Latam)", color: "#ff4d4f", flag: "ğŸ‡§ğŸ‡·", start: {x: 800, y: 1500}, score: 0, alive: true }
        ];

        let entities = [], minerals = [], projectiles = [];

        function initGame() {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            
            // ê° ëŒ€ë¥™ë³„ ë¯¸ë„¤ë„ í’ë¶€í•˜ê²Œ ë°°ì¹˜
            TEAMS.forEach(team => {
                for(let i=0; i<10; i++) {
                    minerals.push({
                        x: team.start.x + (Math.random()-0.5)*600,
                        y: team.start.y + (Math.random()-0.5)*600
                    });
                }
            });

            TEAMS.forEach(team => entities.push({ id: Math.random(), type: 'hq', team: team.id, x: team.start.x, y: team.start.y, hp: 3500, maxHp: 3500, size: 100 }));
            
            // ì¹´ë©”ë¼ë¥¼ í”Œë ˆì´ì–´ ìœ„ì¹˜(ì•„ì‹œì•„)ë¡œ ì´ë™
            camX = TEAMS[0].start.x - canvas.width/2;
            camY = TEAMS[0].start.y - canvas.height/2;

            setInterval(gameLoop, 50);
            requestAnimationFrame(draw);
        }

        function produceUnit(type) {
            const costs = { worker: 50, soldier: 100, tank: 300, tower: 250 };
            if(gold < costs[type]) return;
            gold -= costs[type]; updateUI();
            const hq = entities.find(e => e.team === 1 && e.type === 'hq');
            if(!hq) return;
            const u = { id: Math.random(), type: type, team: 1, x: hq.x + (Math.random()-0.5)*350, y: hq.y + (Math.random()-0.5)*350, cooldown: 0, targetPos: null };
            if(type === 'worker') { u.hp = 150; u.maxHp = 150; u.size = 20; u.speed = 4; u.state = 'idle'; }
            else if(type === 'soldier') { u.hp = 300; u.maxHp = 300; u.size = 20; u.speed = 5; u.range = 180; u.damage = 30; }
            else if(type === 'tank') { u.hp = 600; u.maxHp = 600; u.size = 30; u.speed = 3; u.range = 350; u.damage = 70; u.splash = 100; }
            else if(type === 'tower') { u.hp = 1500; u.maxHp = 1500; u.size = 45; u.speed = 0; u.range = 700; u.damage = 60; }
            entities.push(u);
        }

        function gameLoop() {
            // í¬íƒ„ ì²˜ë¦¬
            for(let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                if(!p.target || p.target.hp <= 0) { projectiles.splice(i, 1); continue; }
                const d = Math.hypot(p.target.x - p.x, p.target.y - p.y);
                if(d < 20) {
                    if(p.splash) {
                        entities.forEach(ent => { if(ent.team !== p.team && Math.hypot(ent.x - p.x, ent.y - p.y) < p.splash) ent.hp -= p.damage; });
                    } else { p.target.hp -= p.damage; }
                    const team = TEAMS.find(t => t.id === p.team);
                    if(p.target.hp <= 0 && team) team.score += (p.target.type === 'hq' ? 200 : 30);
                    projectiles.splice(i, 1);
                } else { p.x += (p.target.x - p.x)/d * p.speed; p.y += (p.target.y - p.y)/d * p.speed; }
            }

            entities.forEach(e => {
                const team = TEAMS.find(t => t.id === e.team);
                if(!team.alive) return;

                if(e.targetPos && e.speed > 0) {
                    const d = Math.hypot(e.targetPos.x - e.x, e.targetPos.y - e.y);
                    if(d > 15) { e.x += (e.targetPos.x - e.x)/d * e.speed; e.y += (e.targetPos.y - e.y)/d * e.speed; }
                    else e.targetPos = null;
                }

                if(e.type === 'worker' && !e.targetPos) {
                    if(e.state === 'idle') {
                        let nearest = null, minDist = Infinity;
                        minerals.forEach(m => { let d = Math.hypot(m.x - e.x, m.y - e.y); if(d < minDist) { minDist = d; nearest = m; } });
                        e.target = nearest; e.state = 'moving_to_mineral';
                    }
                    if(e.state === 'moving_to_mineral' && e.target) {
                        let d = Math.hypot(e.target.x - e.x, e.target.y - e.y);
                        if(d < 20) { e.state = 'mining'; setTimeout(() => { e.state = 'returning'; e.target = entities.find(ent => ent.team === e.team && ent.type === 'hq'); }, 1000); }
                        else { e.x += (e.target.x - e.x)/d * e.speed; e.y += (e.target.y - e.y)/d * e.speed; }
                    }
                    if(e.state === 'returning' && e.target) {
                        let d = Math.hypot(e.target.x - e.x, e.target.y - e.y);
                        if(d < 60) { if(e.team === 1) gold += 20; team.score += 2; updateUI(); e.state = 'idle'; }
                        else { e.x += (e.target.x - e.x)/d * e.speed; e.y += (e.target.y - e.y)/d * e.speed; }
                    }
                }

                if((e.type === 'soldier' || e.type === 'tower' || e.type === 'tank') && !e.targetPos) {
                    if(e.cooldown > 0) e.cooldown--;
                    let enemy = entities.find(ent => ent.team !== e.team && ent.hp > 0 && Math.hypot(ent.x - e.x, ent.y - e.y) < e.range);
                    if(enemy && e.cooldown <= 0) {
                        projectiles.push({ x: e.x, y: e.y, target: enemy, speed: 25, damage: e.damage, team: e.team, type: e.type, splash: e.splash });
                        e.cooldown = e.type === 'tower' ? 35 : (e.type === 'tank' ? 50 : 12);
                    } else if(!enemy && e.type !== 'tower' && e.team !== 1) { // AI ì§„ê²©
                        let targetHQ = entities.find(ent => ent.team === 1 && ent.type === 'hq');
                        if(targetHQ) { let d = Math.hypot(targetHQ.x-e.x, targetHQ.y-e.y); e.x += (targetHQ.x-e.x)/d * e.speed; e.y += (targetHQ.y-e.y)/d * e.speed; }
                    }
                }
            });

            TEAMS.forEach(t => { if(t.alive && !entities.some(ent => ent.team === t.id && ent.type === 'hq')) { t.alive = false; entities = entities.filter(ent => ent.team !== t.id); if(t.id === 1) showEndScreen("MISSION FAILED", "ë‹¹ì‹ ì˜ ë¬¸ëª…ì´ ì§€ë„ì—ì„œ ì‚¬ë¼ì¡ŒìŠµë‹ˆë‹¤."); } });
            entities = entities.filter(e => e.hp > 0);
            updateRanking();
        }

        function draw() {
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save(); ctx.translate(-camX, -camY);

            // ëŒ€ë¥™ ê²½ê³„ì„  (ê°€ìƒì˜ ì„¸ê³„ ì§€ë„ ëŠë‚Œ)
            ctx.strokeStyle = '#020'; ctx.lineWidth = 5;
            ctx.strokeRect(0, 0, W, H);
            for(let i=0; i<W; i+=500) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,H); ctx.stroke(); }
            for(let i=0; i<H; i+=500) { ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(W,i); ctx.stroke(); }

            minerals.forEach(m => { ctx.fillStyle = '#0ff'; ctx.beginPath(); ctx.arc(m.x, m.y, 15, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur=15; ctx.shadowColor='#0ff'; });
            ctx.shadowBlur = 0;

            projectiles.forEach(p => { 
                ctx.fillStyle = p.type === 'tower' ? '#fadb14' : (p.type === 'tank' ? '#f00' : '#fff'); 
                ctx.beginPath(); ctx.arc(p.x, p.y, p.type === 'tower' ? 10 : 5, 0, Math.PI*2); ctx.fill(); 
            });

            entities.forEach(e => {
                const team = TEAMS.find(t => t.id === e.team); ctx.fillStyle = team.color;
                if(selectedUnits.includes(e)) { ctx.strokeStyle = '#0f0'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(e.x, e.y, e.size + 10, 0, Math.PI*2); ctx.stroke(); }
                if(e.type === 'hq') { ctx.fillRect(e.x - 50, e.y - 50, 100, 100); ctx.fillStyle = '#fff'; ctx.font = '40px Arial'; ctx.fillText(team.flag, e.x-25, e.y+15); }
                else if(e.type === 'tower') { ctx.fillRect(e.x - 22, e.y - 22, 44, 44); ctx.fillStyle = '#fff'; ctx.font = '20px Arial'; ctx.fillText('ğŸ›¡ï¸', e.x-14, e.y+10); }
                else if(e.type === 'tank') { ctx.fillRect(e.x - 18, e.y - 18, 36, 36); ctx.fillStyle = '#fff'; ctx.font = '16px Arial'; ctx.fillText('ğŸ’£', e.x-12, e.y+8); }
                else { ctx.beginPath(); ctx.arc(e.x, e.y, 20, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#fff'; ctx.font = 'bold 16px Arial'; ctx.fillText(e.type==='worker'?'â›ï¸':'âš”ï¸', e.x-12, e.y+8); }
                
                ctx.fillStyle = '#500'; ctx.fillRect(e.x - 40, e.y - e.size - 15, 80, 6);
                ctx.fillStyle = '#0f0'; ctx.fillRect(e.x - 40, e.y - e.size - 15, 80 * (e.hp/e.maxHp), 6);
            });

            if(selectionBox) { ctx.strokeStyle = '#0f0'; ctx.lineWidth = 1; ctx.strokeRect(selectionBox.x1, selectionBox.y1, selectionBox.x2 - selectionBox.x1, selectionBox.y2 - selectionBox.y1); ctx.fillStyle = 'rgba(0,255,0,0.1)'; ctx.fillRect(selectionBox.x1, selectionBox.y1, selectionBox.x2 - selectionBox.x1, selectionBox.y2 - selectionBox.y1); }
            ctx.restore(); requestAnimationFrame(draw);
        }

        canvas.addEventListener('mousedown', e => {
            const x = e.clientX + camX, y = e.clientY + camY;
            if(e.button === 0) {
                const clicked = entities.find(ent => Math.hypot(ent.x - x, ent.y - y) < ent.size + 15);
                if(clicked && clicked.team === 1 && clicked.type === 'hq') document.getElementById('build-panel').style.display = 'flex';
                else { document.getElementById('build-panel').style.display = 'none'; selectionBox = { x1: x, y1: y, x2: x, y2: y }; }
            } else if(e.button === 2) {
                selectedUnits.forEach(u => { if(u.speed > 0) u.targetPos = { x: x + (Math.random()-0.5)*150, y: y + (Math.random()-0.5)*150 }; });
            }
        });
        window.addEventListener('mousemove', e => { 
            if(selectionBox) { selectionBox.x2 = e.clientX + camX; selectionBox.y2 = e.clientY + camY; } 
            if(isDragging) { camX -= (e.clientX - lastX); camY -= (e.clientY - lastY); lastX = e.clientX; lastY = e.clientY; camX = Math.max(0, Math.min(W - canvas.width, camX)); camY = Math.max(0, Math.min(H - canvas.height, camY)); }
        });
        window.addEventListener('mouseup', e => {
            if(selectionBox) {
                const xMin = Math.min(selectionBox.x1, selectionBox.x2), xMax = Math.max(selectionBox.x1, selectionBox.x2);
                const yMin = Math.min(selectionBox.y1, selectionBox.y2), yMax = Math.max(selectionBox.y1, selectionBox.y2);
                selectedUnits = entities.filter(ent => ent.team === 1 && ent.speed > 0 && ent.x >= xMin && ent.x <= xMax && ent.y >= yMin && ent.y <= yMax);
                selectionBox = null;
            }
            isDragging = false;
        });
        
        let isDragging = false, lastX, lastY;
        canvas.addEventListener('mousedown', e => { if(e.button === 1 || (e.button === 0 && !entities.find(ent => Math.hypot(ent.x - (e.clientX+camX), ent.y - (e.clientY+camY)) < ent.size + 15))) { isDragging = true; lastX = e.clientX; lastY = e.clientY; } });
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        function updateRanking() { let html = ''; [...TEAMS].sort((a,b)=>b.score-a.score).forEach(t => { html += `<div class="rank-row ${t.id === 1 ? 'me' : ''} ${!t.alive?'eliminated':''}"><span>${t.flag} ${t.name}</span><span>${t.score} PTS</span></div>`; }); document.getElementById('ranks').innerHTML = html; }
        function showEndScreen(title, msg) { document.getElementById('over-title').innerText = title; document.getElementById('over-title').style.color = title.includes("VICTORY")?"#0f0":"#f00"; document.getElementById('over-msg').innerText = msg; document.getElementById('game-over').style.display = 'block'; }
        function updateUI() { document.getElementById('gold-val').innerText = Math.floor(gold); }
        initGame();
    </script>
</body>
</html>
