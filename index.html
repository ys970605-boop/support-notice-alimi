<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>K-Food Conquest .io | ë§›ì§‘ ì˜í†  ì „ìŸ</title>
    <meta property="og:title" content="K-Food Conquest .io" />
    <meta property="og:description" content="ì „ ì„¸ê³„ ìœ ì €ë“¤ê³¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ë²Œì´ëŠ” í•œêµ­ ë§›ì§‘ ë•…ë”°ë¨¹ê¸° ê²Œì„!" />
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #111; overflow: hidden; font-family: 'Apple SD Gothic Neo', sans-serif; touch-action: none; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;
        }

        #scoreboard {
            position: absolute; top: 15px; right: 15px; background: rgba(0,0,0,0.6); border-radius: 10px; padding: 15px; width: 180px; color: #fff; pointer-events: auto;
        }
        .score-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; font-weight: bold; }
        .score-row.me { color: #fadb14; }
        .score-flag { font-size: 18px; margin-right: 8px; }
        .score-bar-bg { flex-grow: 1; height: 8px; background: #333; border-radius: 4px; margin: 0 10px; overflow: hidden; }
        .score-bar { height: 100%; border-radius: 4px; transition: width 0.3s; }
        
        #title-box {
            position: absolute; top: 15px; left: 15px; background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 10px; color: white;
        }
        #title-box h1 { margin: 0; font-size: 18px; color: #fadb14; }
        #title-box p { margin: 5px 0 0 0; font-size: 12px; color: #aaa; }

        #game-over {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); padding: 40px; border-radius: 20px; text-align: center;
            color: white; display: none; pointer-events: auto; border: 2px solid #ff4d4f;
        }
        #game-over h2 { color: #ff4d4f; font-size: 32px; margin-top: 0; }
        #game-over button {
            background: #fadb14; color: #000; border: none; padding: 15px 30px; font-size: 18px; font-weight: bold;
            border-radius: 30px; cursor: pointer; margin-top: 20px;
        }

        canvas { display: block; width: 100%; height: 100%; }

        #controls-hint {
            position: absolute; bottom: 30px; width: 100%; text-align: center; color: rgba(255,255,255,0.5); font-size: 14px; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="title-box">
            <h1>K-Food Conquest .io</h1>
            <p>âš¡ë¶ˆë‹­, ğŸ›¡ï¸ëšë°°ê¸°, ğŸŒŸë¹„ë¹”ë°¥ ì•„ì´í…œì„ ë¨¹ìœ¼ì„¸ìš”!</p>
        </div>
        
        <div id="scoreboard"></div>

        <div id="controls-hint">ë°©í–¥í‚¤ ë˜ëŠ” ìŠ¤ì™€ì´í”„ë¡œ ì¡°ì‘í•˜ì„¸ìš”</div>

        <div id="game-over">
            <h2>ì˜í† ë¥¼ ë¹¼ì•—ê²¼ìŠµë‹ˆë‹¤!</h2>
            <p style="color:#fadb14; font-size: 20px; font-weight: bold;">ìµœì¢… ì ìœ ìœ¨: <span id="final-score">0</span>%</p>
            <button onclick="startGame()">ë‹¤ì‹œ ë„ì „í•˜ê¸°</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const W = 60, H = 60;
        let TILE = 20;
        let offsetX = 0, offsetY = 0;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            TILE = Math.max(window.innerWidth / 40, window.innerHeight / 40);
        }
        window.addEventListener('resize', resize);
        resize();

        const TEAMS = [
            { id: 1, name: "í•œêµ­", flag: "ğŸ‡°ğŸ‡·", color: "#52c41a", trailColor: "rgba(82, 196, 26, 0.5)" },
            { id: 2, name: "ì¤‘êµ­", flag: "ğŸ‡¨ğŸ‡³", color: "#ff4d4f", trailColor: "rgba(255, 77, 79, 0.5)" },
            { id: 3, name: "ì¼ë³¸", flag: "ğŸ‡¯ğŸ‡µ", color: "#d9d9d9", trailColor: "rgba(217, 217, 217, 0.5)" },
            { id: 4, name: "ëŒ€ë§Œ", flag: "ğŸ‡¹ğŸ‡¼", color: "#1890ff", trailColor: "rgba(24, 144, 255, 0.5)" }
        ];

        const ITEM_TYPES = [
            { id: 'speed', emoji: 'âš¡', color: '#ffeb3b', duration: 50 },
            { id: 'shield', emoji: 'ğŸ›¡ï¸', color: '#03a9f4', duration: 80 },
            { id: 'area', emoji: 'ğŸŒŸ', color: '#ff9800', duration: 0 }
        ];

        let gridOwner = [], gridTrail = [], players = [], items = [];
        let gameLoop, isGameOver = false;

        function initGrid() {
            gridOwner = Array(W).fill().map(() => Array(H).fill(0));
            gridTrail = Array(W).fill().map(() => Array(H).fill(0));
            items = [];
        }

        function createPlayer(id, startX, startY) {
            for(let i=-1; i<=1; i++) {
                for(let j=-1; j<=1; j++) {
                    if(startX+i >= 0 && startX+i < W && startY+j >= 0 && startY+j < H) {
                        gridOwner[startX+i][startY+j] = id;
                    }
                }
            }
            return {
                id: id, x: startX, y: startY, dx: 0, dy: -1, nextDx: 0, nextDy: -1,
                trail: [], alive: true, score: 9, effects: { speed: 0, shield: 0 }
            };
        }

        function spawnItem() {
            if (items.length < 8 && Math.random() < 0.05) {
                const ix = Math.floor(Math.random() * W), iy = Math.floor(Math.random() * H);
                if (gridOwner[ix][iy] === 0) {
                    items.push({ x: ix, y: iy, type: ITEM_TYPES[Math.floor(Math.random() * ITEM_TYPES.length)] });
                }
            }
        }

        function startGame() {
            document.getElementById('game-over').style.display = 'none';
            isGameOver = false;
            initGrid();
            players = [
                createPlayer(1, 10, 50), createPlayer(2, 50, 10),
                createPlayer(3, 10, 10), createPlayer(4, 50, 50)
            ];
            if(gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(update, 100);
            window.requestAnimationFrame(draw);
        }

        function captureTerritory(pId) {
            let p = players.find(x => x.id === pId);
            p.trail.forEach(t => { gridOwner[t.x][t.y] = pId; gridTrail[t.x][t.y] = 0; });
            p.trail = [];
            let visited = Array(W).fill().map(() => Array(H).fill(false)), queue = [];
            for(let x=0; x<W; x++) {
                if(gridOwner[x][0] !== pId) { queue.push({x:x, y:0}); visited[x][0] = true; }
                if(gridOwner[x][H-1] !== pId) { queue.push({x:x, y:H-1}); visited[x][H-1] = true; }
            }
            for(let y=0; y<H; y++) {
                if(gridOwner[0][y] !== pId) { queue.push({x:0, y:y}); visited[0][y] = true; }
                if(gridOwner[W-1][y] !== pId) { queue.push({x:W-1, y:y}); visited[W-1][y] = true; }
            }
            let dirs = [[0,1],[0,-1],[1,0],[-1,0]], head = 0;
            while(head < queue.length) {
                let curr = queue[head++];
                for(let d of dirs) {
                    let nx = curr.x + d[0], ny = curr.y + d[1];
                    if(nx>=0 && nx<W && ny>=0 && ny<H && !visited[nx][ny] && gridOwner[nx][ny] !== pId) {
                        visited[nx][ny] = true; queue.push({x:nx, y:ny});
                    }
                }
            }
            for(let x=0; x<W; x++) {
                for(let y=0; y<H; y++) {
                    if(!visited[x][y] && gridOwner[x][y] !== pId) {
                        gridOwner[x][y] = pId; gridTrail[x][y] = 0;
                    }
                }
            }
        }

        function killPlayer(p) {
            p.alive = false;
            for(let x=0; x<W; x++) {
                for(let y=0; y<H; y++) {
                    if(gridOwner[x][y] === p.id) gridOwner[x][y] = 0;
                    if(gridTrail[x][y] === p.id) gridTrail[x][y] = 0;
                }
            }
            if(p.id === 1) { isGameOver = true; clearInterval(gameLoop); document.getElementById('final-score').innerText = ((p.score / (W*H)) * 100).toFixed(1); document.getElementById('game-over').style.display = 'block'; }
        }

        function update() {
            if(isGameOver) return;
            spawnItem();
            players.forEach(p => {
                if(!p.alive) return;
                if (p.effects.speed > 0) p.effects.speed--;
                if (p.effects.shield > 0) p.effects.shield--;
                const moveCount = (p.effects.speed > 0) ? 2 : 1;
                for(let m=0; m < moveCount; m++) {
                    p.dx = p.nextDx; p.dy = p.nextDy;
                    let nx = p.x + p.dx, ny = p.y + p.dy;
                    if(nx < 0 || nx >= W || ny < 0 || ny >= H) { killPlayer(p); break; }
                    const itemIdx = items.findIndex(it => it.x === nx && it.y === ny);
                    if (itemIdx !== -1) {
                        const it = items[itemIdx];
                        if (it.type.id === 'area') {
                            for(let ix=-2; ix<=2; ix++) for(let iy=-2; iy<=2; iy++) if(nx+ix >= 0 && nx+ix < W && ny+iy >= 0 && ny+iy < H) gridOwner[nx+ix][ny+iy] = p.id;
                        } else p.effects[it.type.id] = it.type.duration;
                        items.splice(itemIdx, 1);
                    }
                    if(gridTrail[nx][ny] !== 0) {
                        let victimId = gridTrail[nx][ny], victim = players.find(x => x.id === victimId);
                        if(victim) { if (victim.effects.shield > 0) victim.effects.shield = 0; else killPlayer(victim); }
                        if(victimId === p.id && p.effects.shield <= 0) break;
                    }
                    if(gridOwner[nx][ny] === p.id) { if(p.trail.length > 0) { p.trail.push({x:nx, y:ny}); captureTerritory(p.id); } }
                    else { p.trail.push({x:nx, y:ny}); gridTrail[nx][ny] = p.id; }
                    p.x = nx; p.y = ny;
                }
            });
            let sc = {1:0, 2:0, 3:0, 4:0};
            for(let x=0; x<W; x++) for(let y=0; y<H; y++) if(gridOwner[x][y] !== 0) sc[gridOwner[x][y]]++;
            players.forEach(p => p.score = sc[p.id] || 0);
            updateScoreboard();
        }

        function updateScoreboard() {
            let sorted = [...players].filter(p => p.alive).sort((a,b) => b.score - a.score);
            let html = '';
            sorted.forEach(p => {
                let team = TEAMS.find(t => t.id === p.id);
                let percent = ((p.score / (W*H)) * 100).toFixed(1);
                html += `<div class="score-row ${p.id === 1 ? 'me' : ''}"><span class="score-flag">${team.flag}</span><div class="score-bar-bg"><div class="score-bar" style="width:${percent}%; background-color:${team.color}"></div></div><span>${percent}%</span></div>`;
            });
            document.getElementById('scoreboard').innerHTML = html;
        }

        function draw() {
            if(isGameOver) return;
            ctx.fillStyle = '#222'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            let myPlayer = players.find(p => p.id === 1);
            if(myPlayer) { offsetX = canvas.width/2 - myPlayer.x * TILE; offsetY = canvas.height/2 - myPlayer.y * TILE; }
            ctx.save(); ctx.translate(offsetX, offsetY);
            ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
            for(let x=0; x<=W; x++) { ctx.beginPath(); ctx.moveTo(x*TILE, 0); ctx.lineTo(x*TILE, H*TILE); ctx.stroke(); }
            for(let y=0; y<=H; y++) { ctx.beginPath(); ctx.moveTo(0, y*TILE); ctx.lineTo(W*TILE, y*TILE); ctx.stroke(); }
            for(let x=0; x<W; x++) {
                for(let y=0; y<H; y++) {
                    if(gridOwner[x][y] !== 0) { ctx.fillStyle = TEAMS.find(t => t.id === gridOwner[x][y]).color; ctx.fillRect(x*TILE, y*TILE, TILE, TILE); }
                    if(gridTrail[x][y] !== 0) { ctx.fillStyle = TEAMS.find(t => t.id === gridTrail[x][y]).trailColor; ctx.fillRect(x*TILE + 2, y*TILE + 2, TILE - 4, TILE - 4); }
                }
            }
            items.forEach(it => { ctx.font = `${TILE}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(it.type.emoji, it.x*TILE + TILE/2, it.y*TILE + TILE/2); });
            players.forEach(p => {
                if(!p.alive) return;
                let t = TEAMS.find(team => team.id === p.id);
                if (p.effects.shield > 0) { ctx.strokeStyle = '#03a9f4'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(p.x*TILE + TILE/2, p.y*TILE + TILE/2, TILE*0.8, 0, Math.PI*2); ctx.stroke(); }
                if (p.effects.speed > 0) { ctx.strokeStyle = '#ffeb3b'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(p.x*TILE + TILE/2, p.y*TILE + TILE/2, TILE*0.6, 0, Math.PI*2); ctx.stroke(); }
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(p.x*TILE + TILE/2, p.y*TILE + TILE/2, TILE/2, 0, Math.PI*2); ctx.fill();
                ctx.font = `${TILE*0.8}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(t.flag, p.x*TILE + TILE/2, p.y*TILE + TILE/2 + 2);
            });
            ctx.restore();
            window.requestAnimationFrame(draw);
        }

        window.addEventListener('keydown', e => {
            let myPlayer = players.find(p => p.id === 1);
            if(!myPlayer || !myPlayer.alive) return;
            if(e.key === 'ArrowUp' && myPlayer.dy !== 1) { myPlayer.nextDx = 0; myPlayer.nextDy = -1; }
            if(e.key === 'ArrowDown' && myPlayer.dy !== -1) { myPlayer.nextDx = 0; myPlayer.nextDy = 1; }
            if(e.key === 'ArrowLeft' && myPlayer.dx !== 1) { myPlayer.nextDx = -1; myPlayer.nextDy = 0; }
            if(e.key === 'ArrowRight' && myPlayer.dx !== -1) { myPlayer.nextDx = 1; myPlayer.nextDy = 0; }
        });

        let touchStartX = 0, touchStartY = 0;
        window.addEventListener('touchstart', e => { touchStartX = e.changedTouches[0].screenX; touchStartY = e.changedTouches[0].screenY; }, {passive: false});
        window.addEventListener('touchmove', e => e.preventDefault(), {passive: false});
        window.addEventListener('touchend', e => {
            let myPlayer = players.find(p => p.id === 1); if(!myPlayer || !myPlayer.alive) return;
            let dx = e.changedTouches[0].screenX - touchStartX, dy = e.changedTouches[0].screenY - touchStartY;
            if(Math.abs(dx) > Math.abs(dy)) { if(dx > 30 && myPlayer.dx !== -1) { myPlayer.nextDx = 1; myPlayer.nextDy = 0; } else if(dx < -30 && myPlayer.dx !== 1) { myPlayer.nextDx = -1; myPlayer.nextDy = 0; } }
            else { if(dy > 30 && myPlayer.dy !== -1) { myPlayer.nextDx = 0; myPlayer.nextDy = 1; } else if(dy < -30 && myPlayer.dy !== 1) { myPlayer.nextDx = 0; myPlayer.nextDy = -1; } }
        });

        startGame();
    </script>
</body>
</html>
