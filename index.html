<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>K-Food Conquest .io | ë§›ì§‘ ì˜í†  ì „ìŸ</title>
    <meta property="og:title" content="K-Food Conquest .io" />
    <meta property="og:description" content="ì „ ì„¸ê³„ ìœ ì €ë“¤ê³¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ë²Œì´ëŠ” í•œêµ­ ë§›ì§‘ ë•…ë”°ë¨¹ê¸° ê²Œì„!" />
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #111; overflow: hidden; font-family: 'Apple SD Gothic Neo', sans-serif; touch-action: none; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;
        }

        #scoreboard {
            position: absolute; top: 15px; right: 15px; background: rgba(0,0,0,0.6); border-radius: 10px; padding: 15px; width: 180px; color: #fff; pointer-events: auto;
        }
        .score-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; font-weight: bold; }
        .score-row.me { color: #fadb14; }
        .score-flag { font-size: 18px; margin-right: 8px; }
        .score-bar-bg { flex-grow: 1; height: 8px; background: #333; border-radius: 4px; margin: 0 10px; overflow: hidden; }
        .score-bar { height: 100%; border-radius: 4px; transition: width 0.3s; }
        
        #title-box {
            position: absolute; top: 15px; left: 15px; background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 10px; color: white;
        }
        #title-box h1 { margin: 0; font-size: 18px; color: #fadb14; }
        #title-box p { margin: 5px 0 0 0; font-size: 12px; color: #aaa; }

        #game-over {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); padding: 40px; border-radius: 20px; text-align: center;
            color: white; display: none; pointer-events: auto; border: 2px solid #ff4d4f;
        }
        #game-over h2 { color: #ff4d4f; font-size: 32px; margin-top: 0; }
        #game-over button {
            background: #fadb14; color: #000; border: none; padding: 15px 30px; font-size: 18px; font-weight: bold;
            border-radius: 30px; cursor: pointer; margin-top: 20px;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* ëª¨ë°”ì¼ ì¡°ì‘ ì•ˆë‚´ */
        #controls-hint {
            position: absolute; bottom: 30px; width: 100%; text-align: center; color: rgba(255,255,255,0.5); font-size: 14px; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="title-box">
            <h1>K-Food Conquest .io</h1>
            <p>ë‚´ ì¡°êµ­ì˜ ê¹ƒë°œë¡œ ì˜í† ë¥¼ ë„“í˜€ë¼!</p>
        </div>
        
        <div id="scoreboard">
            <!-- JSë¡œ ì±„ì›Œì§ -->
        </div>

        <div id="controls-hint">í™”ë©´ì„ ìŠ¤ì™€ì´í”„í•˜ê±°ë‚˜ ë°©í–¥í‚¤ë¥¼ ëˆŒëŸ¬ ì´ë™í•˜ì„¸ìš”</div>

        <div id="game-over">
            <h2>ì˜í† ë¥¼ ë¹¼ì•—ê²¼ìŠµë‹ˆë‹¤!</h2>
            <p>ì ì—ê²Œ ê¼¬ë¦¬ë¥¼ ë°Ÿí˜”ê±°ë‚˜ ë²½ì— ë¶€ë”ªí˜”ìŠµë‹ˆë‹¤.</p>
            <p style="color:#fadb14; font-size: 20px; font-weight: bold;">ìµœì¢… ì ìœ ìœ¨: <span id="final-score">0</span>%</p>
            <button onclick="startGame()">ë‹¤ì‹œ ë„ì „í•˜ê¸°</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ê²Œì„ ì„¤ì •
        const W = 60; // ê·¸ë¦¬ë“œ ë„ˆë¹„
        const H = 60; // ê·¸ë¦¬ë“œ ë†’ì´
        let TILE = 20; // íƒ€ì¼ í¬ê¸° (ë°˜ì‘í˜•)
        let offsetX = 0, offsetY = 0;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // í™”ë©´ì— ë§ê²Œ íƒ€ì¼ í¬ê¸° ê³„ì‚° (ê·¸ë¦¬ë“œê°€ í™”ë©´ì— ê½‰ ì°¨ê±°ë‚˜ ë„˜ì¹˜ê²Œ)
            TILE = Math.max(window.innerWidth / 40, window.innerHeight / 40);
        }
        window.addEventListener('resize', resize);
        resize();

        // í”Œë ˆì´ì–´ ë° ë´‡ ì •ë³´
        const TEAMS = [
            { id: 1, name: "í•œêµ­", flag: "ğŸ‡°ğŸ‡·", color: "#52c41a", trailColor: "rgba(82, 196, 26, 0.5)" }, // í”Œë ˆì´ì–´
            { id: 2, name: "ì¤‘êµ­", flag: "ğŸ‡¨ğŸ‡³", color: "#ff4d4f", trailColor: "rgba(255, 77, 79, 0.5)" },
            { id: 3, name: "ì¼ë³¸", flag: "ğŸ‡¯ğŸ‡µ", color: "#d9d9d9", trailColor: "rgba(217, 217, 217, 0.5)" },
            { id: 4, name: "ëŒ€ë§Œ", flag: "ğŸ‡¹ğŸ‡¼", color: "#1890ff", trailColor: "rgba(24, 144, 255, 0.5)" }
        ];

        let gridOwner = [];
        let gridTrail = [];
        let players = [];
        let gameLoop;
        let isGameOver = false;

        function initGrid() {
            gridOwner = Array(W).fill().map(() => Array(H).fill(0));
            gridTrail = Array(W).fill().map(() => Array(H).fill(0));
        }

        function createPlayer(id, startX, startY) {
            // ì´ˆê¸° 3x3 ì˜í† 
            for(let i=-1; i<=1; i++) {
                for(let j=-1; j<=1; j++) {
                    if(startX+i >= 0 && startX+i < W && startY+j >= 0 && startY+j < H) {
                        gridOwner[startX+i][startY+j] = id;
                    }
                }
            }
            return {
                id: id,
                x: startX, y: startY,
                dx: 0, dy: -1, // ì´ˆê¸° ì´ë™ ë°©í–¥ (ìœ„)
                nextDx: 0, nextDy: -1,
                trail: [],
                alive: true,
                score: 9
            };
        }

        function startGame() {
            document.getElementById('game-over').style.display = 'none';
            isGameOver = false;
            initGrid();
            
            // í”Œë ˆì´ì–´ ë° ë´‡ ë°°ì¹˜ (ëª¨ì„œë¦¬ ê·¼ì²˜)
            players = [
                createPlayer(1, Math.floor(W*0.2), Math.floor(H*0.8)), // P1 (í•˜ë‹¨ ì¢Œì¸¡)
                createPlayer(2, Math.floor(W*0.8), Math.floor(H*0.2)), // B1
                createPlayer(3, Math.floor(W*0.2), Math.floor(H*0.2)), // B2
                createPlayer(4, Math.floor(W*0.8), Math.floor(H*0.8))  // B3
            ];

            if(gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(update, 100); // ì†ë„ (100ms ë§ˆë‹¤ 1ì¹¸)
            window.requestAnimationFrame(draw);
        }

        // ì˜ì—­ ì±„ìš°ê¸° ì•Œê³ ë¦¬ì¦˜ (Flood Fill ë°©ì‹ì„ ì´ìš©í•œ ì™¸ê³½ íŒë³„)
        function captureTerritory(pId) {
            // 1. íŠ¸ë ˆì¼ì„ ë‚´ ì˜í† ë¡œ ë³€í™˜
            let p = players.find(x => x.id === pId);
            p.trail.forEach(t => {
                gridOwner[t.x][t.y] = pId;
                gridTrail[t.x][t.y] = 0;
            });
            p.trail = [];

            // 2. ì™¸ê³½ì„ (Edge)ì—ì„œ ì‹œì‘í•˜ì—¬ ë‚´ ì˜í† ê°€ ì•„ë‹Œ ê³³ì„ ëª¨ë‘ íƒìƒ‰ (Flood Fill)
            let visited = Array(W).fill().map(() => Array(H).fill(false));
            let queue = [];

            // ì™¸ê³½ í”½ì…€ íì— ì‚½ì…
            for(let x=0; x<W; x++) {
                if(gridOwner[x][0] !== pId) { queue.push({x:x, y:0}); visited[x][0] = true; }
                if(gridOwner[x][H-1] !== pId) { queue.push({x:x, y:H-1}); visited[x][H-1] = true; }
            }
            for(let y=0; y<H; y++) {
                if(gridOwner[0][y] !== pId) { queue.push({x:0, y:y}); visited[0][y] = true; }
                if(gridOwner[W-1][y] !== pId) { queue.push({x:W-1, y:y}); visited[W-1][y] = true; }
            }

            // BFS
            let dirs = [[0,1],[0,-1],[1,0],[-1,0]];
            let head = 0;
            while(head < queue.length) {
                let curr = queue[head++];
                for(let d of dirs) {
                    let nx = curr.x + d[0];
                    let ny = curr.y + d[1];
                    if(nx>=0 && nx<W && ny>=0 && ny<H) {
                        if(!visited[nx][ny] && gridOwner[nx][ny] !== pId) {
                            visited[nx][ny] = true;
                            queue.push({x:nx, y:ny});
                        }
                    }
                }
            }

            // 3. ë°©ë¬¸í•˜ì§€ ì•Šì€ ì˜ì—­(ê°‡íŒ ì˜ì—­)ì€ ë‚´ ì˜í† ë¡œ í¸ì…
            for(let x=0; x<W; x++) {
                for(let y=0; y<H; y++) {
                    if(!visited[x][y] && gridOwner[x][y] !== pId) {
                        gridOwner[x][y] = pId;
                        gridTrail[x][y] = 0; // ë‚¨ì˜ íŠ¸ë ˆì¼ ì§€ìš°ê¸°
                    }
                }
            }
        }

        function killPlayer(p) {
            p.alive = false;
            // ì˜í†  ë° íŠ¸ë ˆì¼ ì§€ìš°ê¸°
            for(let x=0; x<W; x++) {
                for(let y=0; y<H; y++) {
                    if(gridOwner[x][y] === p.id) gridOwner[x][y] = 0;
                    if(gridTrail[x][y] === p.id) gridTrail[x][y] = 0;
                }
            }
            if(p.id === 1) { // ë‚´ê°€ ì£½ìŒ
                isGameOver = true;
                clearInterval(gameLoop);
                document.getElementById('final-score').innerText = ((p.score / (W*H)) * 100).toFixed(1);
                document.getElementById('game-over').style.display = 'block';
            }
        }

        // ì•„ì£¼ ë‹¨ìˆœí•œ ë´‡ AI
        function updateBots() {
            players.forEach(p => {
                if(p.id === 1 || !p.alive) return; // ë‚˜(1) ì œì™¸
                
                let possibleMoves = [[0,-1],[0,1],[-1,0],[1,0]].filter(d => {
                    if(d[0] === -p.dx && d[1] === -p.dy) return false; // í›„ì§„ ê¸ˆì§€
                    let nx = p.x + d[0], ny = p.y + d[1];
                    if(nx < 0 || nx >= W || ny < 0 || ny >= H) return false; // ë²½ í”¼í•˜ê¸°
                    if(gridTrail[nx][ny] === p.id) return false; // ìê¸° ê¼¬ë¦¬ í”¼í•˜ê¸°
                    return true;
                });

                if(possibleMoves.length > 0) {
                    // ì§ì§„ì„ ì„ í˜¸í•˜ë˜ ê°€ë” ë°©í–¥ ì „í™˜
                    let goStraight = possibleMoves.find(d => d[0] === p.dx && d[1] === p.dy);
                    if(goStraight && Math.random() > 0.1) {
                        p.nextDx = goStraight[0]; p.nextDy = goStraight[1];
                    } else {
                        let randMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        p.nextDx = randMove[0]; p.nextDy = randMove[1];
                    }
                }
            });
        }

        function update() {
            if(isGameOver) return;

            updateBots();

            // ì ìˆ˜ ê³„ì‚°ìš©
            let scores = {1:0, 2:0, 3:0, 4:0};

            players.forEach(p => {
                if(!p.alive) return;

                p.dx = p.nextDx;
                p.dy = p.nextDy;
                let nx = p.x + p.dx;
                let ny = p.y + p.dy;

                // ë²½ ì¶©ëŒ ì²´í¬
                if(nx < 0 || nx >= W || ny < 0 || ny >= H) {
                    killPlayer(p);
                    return;
                }

                // ë‹¤ë¥¸ ì‚¬ëŒì´ë‚˜ ë‚´ ê¼¬ë¦¬ ë°ŸìŒ ì²´í¬
                if(gridTrail[nx][ny] !== 0) {
                    let victimId = gridTrail[nx][ny];
                    let victim = players.find(x => x.id === victimId);
                    if(victim) killPlayer(victim);
                    
                    if(victimId === p.id) return; // ë‚´ê°€ ë‚´ ê¼¬ë¦¬ ë°Ÿê³  ì£½ì—ˆìœ¼ë©´ ì—¬ê¸°ì„œ ì¢…ë£Œ
                }

                // ì´ë™ ì²˜ë¦¬
                if(gridOwner[nx][ny] === p.id) {
                    // ë‚´ ì˜í† ë¡œ ëŒì•„ì˜´
                    if(p.trail.length > 0) {
                        p.trail.push({x:nx, y:ny}); // ì¼ë‹¨ íŠ¸ë ˆì¼ì— ì¶”ê°€
                        captureTerritory(p.id);
                    }
                } else {
                    // ë‚¨ì˜ ì˜í† ë‚˜ ë¹ˆ ë•… íƒí—˜ ì¤‘ -> íŠ¸ë ˆì¼ ë‚¨ê¹€
                    p.trail.push({x:nx, y:ny});
                    gridTrail[nx][ny] = p.id;
                }

                p.x = nx;
                p.y = ny;
            });

            // ì ìˆ˜ ì§‘ê³„
            for(let x=0; x<W; x++) {
                for(let y=0; y<H; y++) {
                    if(gridOwner[x][y] !== 0) {
                        scores[gridOwner[x][y]]++;
                    }
                }
            }
            players.forEach(p => p.score = scores[p.id] || 0);

            updateScoreboard();
        }

        function updateScoreboard() {
            let sorted = [...players].filter(p => p.alive).sort((a,b) => b.score - a.score);
            let html = '';
            sorted.forEach((p, idx) => {
                let team = TEAMS.find(t => t.id === p.id);
                let percent = ((p.score / (W*H)) * 100).toFixed(1);
                html += `
                    <div class="score-row ${p.id === 1 ? 'me' : ''}">
                        <span class="score-flag">${team.flag}</span>
                        <div class="score-bar-bg">
                            <div class="score-bar" style="width:${percent}%; background-color:${team.color}"></div>
                        </div>
                        <span>${percent}%</span>
                    </div>
                `;
            });
            document.getElementById('scoreboard').innerHTML = html;
        }

        function draw() {
            if(isGameOver) return;

            ctx.fillStyle = '#222';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ì¹´ë©”ë¼ ì¤‘ì‹¬ì„ í”Œë ˆì´ì–´ì— ë§ì¶¤
            let myPlayer = players.find(p => p.id === 1);
            if(myPlayer) {
                offsetX = canvas.width/2 - myPlayer.x * TILE;
                offsetY = canvas.height/2 - myPlayer.y * TILE;
            }

            ctx.save();
            ctx.translate(offsetX, offsetY);

            // ê·¸ë¦¬ë“œ ë°°ê²½
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for(let x=0; x<=W; x++) {
                ctx.beginPath(); ctx.moveTo(x*TILE, 0); ctx.lineTo(x*TILE, H*TILE); ctx.stroke();
            }
            for(let y=0; y<=H; y++) {
                ctx.beginPath(); ctx.moveTo(0, y*TILE); ctx.lineTo(W*TILE, y*TILE); ctx.stroke();
            }

            // ì˜í†  ë° ê¼¬ë¦¬ ê·¸ë¦¬ê¸°
            for(let x=0; x<W; x++) {
                for(let y=0; y<H; y++) {
                    if(gridOwner[x][y] !== 0) {
                        let t = TEAMS.find(team => team.id === gridOwner[x][y]);
                        ctx.fillStyle = t.color;
                        ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
                    }
                    if(gridTrail[x][y] !== 0) {
                        let t = TEAMS.find(team => team.id === gridTrail[x][y]);
                        ctx.fillStyle = t.trailColor;
                        ctx.fillRect(x*TILE + 2, y*TILE + 2, TILE - 4, TILE - 4);
                    }
                }
            }

            // í”Œë ˆì´ì–´(í—¤ë“œ) ë° êµ­ê¸° ê·¸ë¦¬ê¸°
            players.forEach(p => {
                if(!p.alive) return;
                let t = TEAMS.find(team => team.id === p.id);
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(p.x*TILE + TILE/2, p.y*TILE + TILE/2, TILE/2, 0, Math.PI*2);
                ctx.fill();
                
                // ì´ëª¨ì§€ êµ­ê¸° ê·¸ë¦¬ê¸°
                ctx.font = `${TILE*0.8}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(t.flag, p.x*TILE + TILE/2, p.y*TILE + TILE/2 + 2);
            });

            ctx.restore();

            window.requestAnimationFrame(draw);
        }

        // ì¡°ì‘ (PC ë°©í–¥í‚¤)
        window.addEventListener('keydown', e => {
            let myPlayer = players.find(p => p.id === 1);
            if(!myPlayer || !myPlayer.alive) return;

            if(e.key === 'ArrowUp' && myPlayer.dy !== 1) { myPlayer.nextDx = 0; myPlayer.nextDy = -1; }
            if(e.key === 'ArrowDown' && myPlayer.dy !== -1) { myPlayer.nextDx = 0; myPlayer.nextDy = 1; }
            if(e.key === 'ArrowLeft' && myPlayer.dx !== 1) { myPlayer.nextDx = -1; myPlayer.nextDy = 0; }
            if(e.key === 'ArrowRight' && myPlayer.dx !== -1) { myPlayer.nextDx = 1; myPlayer.nextDy = 0; }
        });

        // ì¡°ì‘ (ëª¨ë°”ì¼ ìŠ¤ì™€ì´í”„)
        let touchStartX = 0, touchStartY = 0;
        window.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, {passive: false});

        window.addEventListener('touchmove', e => e.preventDefault(), {passive: false});

        window.addEventListener('touchend', e => {
            let myPlayer = players.find(p => p.id === 1);
            if(!myPlayer || !myPlayer.alive) return;

            let touchEndX = e.changedTouches[0].screenX;
            let touchEndY = e.changedTouches[0].screenY;
            
            let dx = touchEndX - touchStartX;
            let dy = touchEndY - touchStartY;
            
            if(Math.abs(dx) > Math.abs(dy)) {
                // ì¢Œìš° ìŠ¤ì™€ì´í”„
                if(dx > 30 && myPlayer.dx !== -1) { myPlayer.nextDx = 1; myPlayer.nextDy = 0; }
                else if(dx < -30 && myPlayer.dx !== 1) { myPlayer.nextDx = -1; myPlayer.nextDy = 0; }
            } else {
                // ìƒí•˜ ìŠ¤ì™€ì´í”„
                if(dy > 30 && myPlayer.dy !== -1) { myPlayer.nextDx = 0; myPlayer.nextDy = 1; }
                else if(dy < -30 && myPlayer.dy !== 1) { myPlayer.nextDx = 0; myPlayer.nextDy = -1; }
            }
        });

        // ê²Œì„ ì‹œì‘
        startGame();

    </script>
</body>
</html>
