<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>K-Food Conquest .io | ë¬¸ëª… ì§„í™” ì „ìŸ</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #0a0a12; overflow: hidden; font-family: 'Apple SD Gothic Neo', sans-serif; touch-action: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        #scoreboard { position: absolute; top: 15px; right: 15px; background: rgba(0,0,0,0.7); border-radius: 12px; padding: 15px; width: 200px; color: #fff; pointer-events: auto; border: 1px solid #333; }
        .score-row { display: flex; flex-direction: column; margin-bottom: 10px; }
        .score-info { display: flex; justify-content: space-between; font-weight: bold; font-size: 13px; margin-bottom: 4px; }
        .score-bar-bg { width: 100%; height: 6px; background: #222; border-radius: 3px; overflow: hidden; }
        .score-bar { height: 100%; transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1); }
        .score-level { font-size: 10px; color: #fadb14; margin-top: 2px; }
        
        #title-box { position: absolute; top: 15px; left: 15px; background: rgba(0,0,0,0.7); padding: 12px 20px; border-radius: 12px; color: white; border: 1px solid #333; }
        #title-box h1 { margin: 0; font-size: 20px; color: #fadb14; text-shadow: 0 0 10px rgba(250, 219, 20, 0.5); }
        #title-box p { margin: 5px 0 0 0; font-size: 12px; color: #00d2ff; font-weight: bold; }

        #level-up-toast {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            background: rgba(250, 219, 20, 0.9); color: #000; padding: 10px 30px;
            border-radius: 50px; font-weight: 900; font-size: 24px;
            display: none; z-index: 100; animation: bounce 0.5s infinite alternate;
        }
        @keyframes bounce { from { transform: translate(-50%, 0); } to { transform: translate(-50%, -10px); } }

        #game-over { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 40px; border-radius: 20px; text-align: center; color: white; display: none; pointer-events: auto; border: 2px solid #ff4d4f; }
        #game-over button { background: #fadb14; color: #000; border: none; padding: 15px 30px; font-size: 18px; font-weight: bold; border-radius: 30px; cursor: pointer; margin-top: 20px; }
        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div id="title-box">
            <h1>ë¬¸ëª… ì§„í™” ì „ìŸ .io</h1>
            <p id="my-stage">í˜„ì¬ ì‹œëŒ€: ê°œì²™ ì‹œëŒ€ â›º</p>
        </div>
        <div id="scoreboard"></div>
        <div id="level-up-toast">LEVEL UP! ë¬¸ëª… ì§„í™” ğŸš€</div>
        <div id="game-over">
            <h2>ë¬¸ëª…ì´ ë©¸ë§í–ˆìŠµë‹ˆë‹¤!</h2>
            <p>ìµœì¢… ì ìœ ìœ¨: <span id="final-score">0</span>%</p>
            <button onclick="startGame()">ìƒˆë¡œìš´ ë¬¸ëª… ì‹œì‘</button>
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = 60, H = 60;
        let TILE = 30;
        let offsetX = 0, offsetY = 0;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            TILE = Math.max(window.innerWidth / 35, window.innerHeight / 35);
        }
        window.addEventListener('resize', resize);
        resize();

        const TEAMS = [
            { id: 1, name: "í•œêµ­", flag: "ğŸ‡°ğŸ‡·", color: "#52c41a", trailColor: "rgba(82, 196, 26, 0.3)" },
            { id: 2, name: "ì¤‘êµ­", flag: "ğŸ‡¨ğŸ‡³", color: "#ff4d4f", trailColor: "rgba(255, 77, 79, 0.3)" },
            { id: 3, name: "ì¼ë³¸", flag: "ğŸ‡¯ğŸ‡µ", color: "#d9d9d9", trailColor: "rgba(217, 217, 217, 0.3)" },
            { id: 4, name: "ëŒ€ë§Œ", flag: "ğŸ‡¹ğŸ‡¼", color: "#1890ff", trailColor: "rgba(24, 144, 255, 0.3)" }
        ];

        // ì§„í™” ë‹¨ê³„ ì •ì˜
        const STAGES = [
            { min: 0, name: "ê°œì²™ ì‹œëŒ€", emoji: "â›º", build: ["â›º", "ğŸ”¥"] },
            { min: 5, name: "ì •ì°© ì‹œëŒ€", emoji: "ğŸ ", build: ["ğŸ ", "ğŸ¡"] },
            { min: 15, name: "ë„ì‹œ ì‹œëŒ€", emoji: "ğŸ¢", build: ["ğŸ¢", "ğŸª", "ğŸ«"] },
            { min: 30, name: "ë©”íŠ¸ë¡œí´ë¦¬ìŠ¤", emoji: "ğŸ™ï¸", build: ["ğŸ™ï¸", "ğŸ›ï¸", "ğŸ—¼"] },
            { min: 50, name: "ë¯¸ë˜ ë¬¸ëª…", emoji: "ğŸš€", build: ["ğŸš€", "ğŸ›°ï¸", "ğŸ›¸"] }
        ];

        let gridOwner = [], gridTrail = [], gridBuildings = [], players = [], items = [];
        let gameLoop, isGameOver = false;

        function initGrid() {
            gridOwner = Array(W).fill().map(() => Array(H).fill(0));
            gridTrail = Array(W).fill().map(() => Array(H).fill(0));
            gridBuildings = Array(W).fill().map(() => Array(H).fill(""));
        }

        function getStage(percent) {
            for (let i = STAGES.length - 1; i >= 0; i--) {
                if (percent >= STAGES[i].min) return { ...STAGES[i], level: i + 1 };
            }
            return { ...STAGES[0], level: 1 };
        }

        function createPlayer(id, startX, startY) {
            for(let i=-1; i<=1; i++) {
                for(let j=-1; j<=1; j++) {
                    if(startX+i >= 0 && startX+i < W && startY+j >= 0 && startY+j < H) {
                        gridOwner[startX+i][startY+j] = id;
                        if (Math.random() < 0.3) gridBuildings[startX+i][startY+j] = STAGES[0].build[0];
                    }
                }
            }
            return {
                id: id, x: startX, y: startY, dx: 0, dy: -1, nextDx: 0, nextDy: -1,
                trail: [], alive: true, score: 9, level: 1, effects: { speed: 0, shield: 0 }
            };
        }

        function startGame() {
            document.getElementById('game-over').style.display = 'none';
            isGameOver = false;
            initGrid();
            players = [
                createPlayer(1, 10, 50), createPlayer(2, 50, 10),
                createPlayer(3, 10, 10), createPlayer(4, 50, 50)
            ];
            if(gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(update, 100);
            window.requestAnimationFrame(draw);
        }

        function captureTerritory(pId) {
            let p = players.find(x => x.id === pId);
            p.trail.forEach(t => { gridOwner[t.x][t.y] = pId; gridTrail[t.x][t.y] = 0; });
            p.trail = [];
            let visited = Array(W).fill().map(() => Array(H).fill(false)), queue = [];
            for(let x=0; x<W; x++) {
                if(gridOwner[x][0] !== pId) { queue.push({x:x, y:0}); visited[x][0] = true; }
                if(gridOwner[x][H-1] !== pId) { queue.push({x:x, y:H-1}); visited[x][H-1] = true; }
            }
            for(let y=0; y<H; y++) {
                if(gridOwner[0][y] !== pId) { queue.push({x:0, y:y}); visited[0][y] = true; }
                if(gridOwner[W-1][y] !== pId) { queue.push({x:W-1, y:y}); visited[W-1][y] = true; }
            }
            let dirs = [[0,1],[0,-1],[1,0],[-1,0]], head = 0;
            while(head < queue.length) {
                let curr = queue[head++];
                for(let d of dirs) {
                    let nx = curr.x + d[0], ny = curr.y + d[1];
                    if(nx>=0 && nx<W && ny>=0 && ny<H && !visited[nx][ny] && gridOwner[nx][ny] !== pId) {
                        visited[nx][ny] = true; queue.push({x:nx, y:ny});
                    }
                }
            }
            const stage = getStage((p.score / (W*H)) * 100);
            for(let x=0; x<W; x++) {
                for(let y=0; y<H; y++) {
                    if(!visited[x][y] && gridOwner[x][y] !== pId) {
                        gridOwner[x][y] = pId; gridTrail[x][y] = 0;
                        if (Math.random() < 0.2) gridBuildings[x][y] = stage.build[Math.floor(Math.random()*stage.build.length)];
                    }
                }
            }
        }

        function killPlayer(p) {
            p.alive = false;
            for(let x=0; x<W; x++) {
                for(let y=0; y<H; y++) {
                    if(gridOwner[x][y] === p.id) { gridOwner[x][y] = 0; gridBuildings[x][y] = ""; }
                    if(gridTrail[x][y] === p.id) gridTrail[x][y] = 0;
                }
            }
            if(p.id === 1) { isGameOver = true; clearInterval(gameLoop); document.getElementById('final-score').innerText = ((p.score / (W*H)) * 100).toFixed(1); document.getElementById('game-over').style.display = 'block'; }
        }

        function update() {
            if(isGameOver) return;
            players.forEach(p => {
                if(!p.alive) return;
                p.dx = p.nextDx; p.dy = p.nextDy;
                let nx = p.x + p.dx, ny = p.y + p.dy;
                if(nx < 0 || nx >= W || ny < 0 || ny >= H) { killPlayer(p); return; }
                if(gridTrail[nx][ny] !== 0) {
                    let victimId = gridTrail[nx][ny], victim = players.find(x => x.id === victimId);
                    if(victim) killPlayer(victim);
                    if(victimId === p.id) return;
                }
                if(gridOwner[nx][ny] === p.id) { if(p.trail.length > 0) { captureTerritory(p.id); } }
                else { p.trail.push({x:nx, y:ny}); gridTrail[nx][ny] = p.id; }
                p.x = nx; p.y = ny;
            });
            let sc = {1:0, 2:0, 3:0, 4:0};
            for(let x=0; x<W; x++) for(let y=0; y<H; y++) if(gridOwner[x][y] !== 0) sc[gridOwner[x][y]]++;
            players.forEach(p => {
                const oldLevel = p.level;
                p.score = sc[p.id] || 0;
                const percent = (p.score / (W*H)) * 100;
                const stage = getStage(percent);
                p.level = stage.level;
                if (p.id === 1) document.getElementById('my-stage').innerText = `í˜„ì¬ ì‹œëŒ€: ${stage.name} ${stage.emoji}`;
                if (p.level > oldLevel) {
                    if (p.id === 1) {
                        const toast = document.getElementById('level-up-toast');
                        toast.innerText = `${stage.name} ì§„í™”! ${stage.emoji}`;
                        toast.style.display = 'block';
                        setTimeout(() => toast.style.display = 'none', 3000);
                    }
                    // ëª¨ë“  ê±´ë¬¼ ì—…ê·¸ë ˆì´ë“œ
                    for(let x=0; x<W; x++) for(let y=0; y<H; y++) if(gridOwner[x][y] === p.id && gridBuildings[x][y] !== "") gridBuildings[x][y] = stage.build[Math.floor(Math.random()*stage.build.length)];
                }
            });
            updateScoreboard();
        }

        function updateScoreboard() {
            let sorted = [...players].filter(p => p.alive).sort((a,b) => b.score - a.score);
            let html = '';
            sorted.forEach(p => {
                let team = TEAMS.find(t => t.id === p.id);
                let percent = ((p.score / (W*H)) * 100).toFixed(1);
                let stage = getStage(percent);
                html += `
                    <div class="score-row">
                        <div class="score-info">
                            <span>${team.flag} ${team.name}</span>
                            <span>${percent}%</span>
                        </div>
                        <div class="score-bar-bg">
                            <div class="score-bar" style="width:${percent}%; background-color:${team.color}"></div>
                        </div>
                        <div class="score-level">${stage.name}</div>
                    </div>`;
            });
            document.getElementById('scoreboard').innerHTML = html;
        }

        function draw() {
            if(isGameOver) return;
            ctx.fillStyle = '#0a0a12'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            let myPlayer = players.find(p => p.id === 1);
            if(myPlayer) { offsetX = canvas.width/2 - myPlayer.x * TILE; offsetY = canvas.height/2 - myPlayer.y * TILE; }
            ctx.save(); ctx.translate(offsetX, offsetY);
            
            // ê·¸ë¦¬ë“œ ì„  (ë°°ê²½)
            ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth = 1;
            for(let x=0; x<=W; x++) { ctx.beginPath(); ctx.moveTo(x*TILE, 0); ctx.lineTo(x*TILE, H*TILE); ctx.stroke(); }
            for(let y=0; y<=H; y++) { ctx.beginPath(); ctx.moveTo(0, y*TILE); ctx.lineTo(W*TILE, y*TILE); ctx.stroke(); }

            // ì˜í†  ì±„ìš°ê¸°
            for(let x=0; x<W; x++) {
                for(let y=0; y<H; y++) {
                    const ownerId = gridOwner[x][y];
                    if(ownerId !== 0) {
                        const t = TEAMS.find(team => team.id === ownerId);
                        ctx.fillStyle = t.color;
                        ctx.globalAlpha = 0.2;
                        ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
                        ctx.globalAlpha = 1.0;
                        // ê±´ë¬¼ ê·¸ë¦¬ê¸°
                        if (gridBuildings[x][y] !== "") {
                            ctx.font = `${TILE * 0.6}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(gridBuildings[x][y], x*TILE + TILE/2, y*TILE + TILE/2);
                        }
                    }
                    if(gridTrail[x][y] !== 0) {
                        const t = TEAMS.find(team => team.id === gridTrail[x][y]);
                        ctx.fillStyle = t.color;
                        ctx.fillRect(x*TILE + TILE*0.25, y*TILE + TILE*0.25, TILE*0.5, TILE*0.5);
                    }
                }
            }

            // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
            players.forEach(p => {
                if(!p.alive) return;
                const t = TEAMS.find(team => team.id === p.id);
                ctx.shadowBlur = 15; ctx.shadowColor = t.color;
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(p.x*TILE + TILE/2, p.y*TILE + TILE/2, TILE*0.4, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
                ctx.font = `${TILE*0.6}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(t.flag, p.x*TILE + TILE/2, p.y*TILE + TILE/2 + 2);
            });
            ctx.restore();
            window.requestAnimationFrame(draw);
        }

        window.addEventListener('keydown', e => {
            let myPlayer = players.find(p => p.id === 1); if(!myPlayer || !myPlayer.alive) return;
            if(e.key === 'ArrowUp' && myPlayer.dy !== 1) { myPlayer.nextDx = 0; myPlayer.nextDy = -1; }
            if(e.key === 'ArrowDown' && myPlayer.dy !== -1) { myPlayer.nextDx = 0; myPlayer.nextDy = 1; }
            if(e.key === 'ArrowLeft' && myPlayer.dx !== 1) { myPlayer.nextDx = -1; myPlayer.nextDy = 0; }
            if(e.key === 'ArrowRight' && myPlayer.dx !== -1) { myPlayer.nextDx = 1; myPlayer.nextDy = 0; }
        });

        let touchStartX = 0, touchStartY = 0;
        window.addEventListener('touchstart', e => { touchStartX = e.changedTouches[0].screenX; touchStartY = e.changedTouches[0].screenY; }, {passive: false});
        window.addEventListener('touchmove', e => e.preventDefault(), {passive: false});
        window.addEventListener('touchend', e => {
            let myPlayer = players.find(p => p.id === 1); if(!myPlayer || !myPlayer.alive) return;
            let dx = e.changedTouches[0].screenX - touchStartX, dy = e.changedTouches[0].screenY - touchStartY;
            if(Math.abs(dx) > Math.abs(dy)) {
                if(dx > 30 && myPlayer.dx !== -1) { myPlayer.nextDx = 1; myPlayer.nextDy = 0; }
                else if(dx < -30 && myPlayer.dx !== 1) { myPlayer.nextDx = -1; myPlayer.nextDy = 0; }
            } else {
                if(dy > 30 && myPlayer.dy !== -1) { myPlayer.nextDx = 0; myPlayer.nextDy = 1; }
                else if(dy < -30 && myPlayer.dy !== 1) { myPlayer.nextDx = 0; myPlayer.nextDy = -1; }
            }
        });

        startGame();
    </script>
</body>
</html>
